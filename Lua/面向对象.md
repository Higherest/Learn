### Class.lua

``` lua
local class = {}
local constructorKeyword = "Ctor"
local baseKeyword = "base"

local function NewClass(_, baseClassPrototype)
    local classPrototype = {}
    classPrototype.base = baseClassPrototype   -- 保存父类类型模板
    classPrototype.__index = classPrototype   -- 访问实例的字段其实是访问类型模板的字段
    local classMetatable = class.classMetatable
    if not classMetatable then
        classMetatable = {
            -- 调用classPrototype(params)来创建实例时调用，相当于 new classPrototype(params)
            __call = function (classPrototype, ...)
                -- 创建类的实例
                local obj = {}
                -- 访问实例的字段时，如果不存在将调用__index对应的function
                setmetatable(obj, classPrototype)
                local constructRecursively
                ---- 类的构造函数，递归地向父类追溯，从最内层的父类开始调用构造函数，参数来自最外层子类的构造函数
                constructRecursively = function(classPrototype, ...)
                    if not classPrototype then return end
                    constructRecursively(rawget(classPrototype, baseKeyword))
                    local constructor = rawget(classPrototype, constructorKeyword)
                    if constructor then constructor(obj, ...) end
                end
                constructRecursively(classPrototype, ...)
                return obj
            end,
            -- 由于通过设置classPrototype的元表为_class_metatable，并设置__call元方法来作为创建实例的方法
            -- 这里就不能再通过设置类模板的元表的__index为父类模板来实现继承了，只好在function里自行处理继承关系
            __index = function (classPrototype, key)
                -- 取得类型模板的父类类型模板
                local baseClassPrototype = rawget(classPrototype, baseKeyword)
                -- 继续访问key，如果找不到还会触发这个__index，一直往父类追溯
                if baseClassPrototype then return baseClassPrototype[key]
                else return nil end
            end,
            __tostring = function()
                local message
                for key, value in pairs(self) do
                    message = message .. string.format("key:{0} = {1}", key, value)
                end
                return message
            end
        }
        class.classMetatable = classMetatable
    end
    -- 设置类型模板的元表（仅为了__call元方法）
    setmetatable(classPrototype, classMetatable)
    -- 最后返回类型模板
    return classPrototype
end

-- 可以用 classPrototype = class(baseClassPrototype) 来创建类型模板
setmetatable(class, { __call = NewClass })

return class
```

### 范例（包含EmmyLua注解）

#### ClassA.lua

``` lua
local class = require("Lua.Class")

---@class ClassA
---@field field1 number
local ClassA = class()
ClassA.field1 = 1
function ClassA.Ctor()
    print("ClassA.New()")
end
function ClassA:Method1()
    print("ClassA.field1 = " .. self.field1)
end

return ClassA
```

#### ClassB.lua

``` lua
local class = require("Lua.Class")
local ClassA = require("Lua.ClassA")

---@class ClassB : ClassA
---@field field2 number
local ClassB = class(ClassA)
ClassB.field2 = 2
function ClassB:Ctor()
    self.field1 = 111
    print("ClassB.New()")
end
function ClassB:Method2()
    print("ClassB.field1 = " .. self.field1)
    print("ClassB.field2 = " .. self.field2)
end

return ClassB
```

#### Main.lua

``` lua
-- 加载模块
local class = require("Lua.Class")
-- 声明类型
---@type ClassA
local ClassA = require("Lua.ClassA")
---@type ClassB
local ClassB = require("Lua.ClassB")

--local a = ClassA()
--a:Method1()
--print(tostring(a))

local b = ClassB()
b:Method2()
-- 可通过base访问父类方法
b.base:Method1()

-- 泛型工厂方法

local Character = class()
---@generic TCharacter : ClassA
---@param prototype TCharacter
function Character.Create(prototype)
    return prototype()
end

local characterA = Character.Create(ClassA)
characterA:Method1()
characterA.field1 = 123

local characterB = Character.Create(ClassB)
characterB.field1 = 321
characterB.field2 = 233
characterB:Method2()
```

