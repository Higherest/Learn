## 作用域和范围

为 对象 分配 的 内存， 其 存活 时间 称为 储存 期（ storage duration） 或 范围（ extent）。释放。 我们 称 此 对象 具有 局部 性 范围（ local extent）。对象 在 程序 内 的 存活 区域 称为 该 对象 的 scope（ 作用域）。如果 某个 对象 仅 具有 local scope（ 局部 作用域），其 名称 在 local scope 之外 便 不 可见。

对象 如果 在 函数 以外 声明， 具有 所谓 的 file scope。 对象 如果 拥有 file scope， 从其 声明 点 至 文件 末尾 都是 可见 的。 file scope 内 的 对象 也 具备 所谓 的 static extent， 意即 该 对象 的 内存 在 main（） 开始 执行 之前 便 已经 分配 好了， 可以 一直 存在 至 程序 结束。 内置 类型 的 对象， 如果 定义 在 file scope 之内， 必定 被 初始 化为 0。 但如 果 它们 被 定义 于 local scope 之内， 那么 除非 程序员 指定 其 初值， 否则 不 会被 初始化。

动态 内存 管理 不论 local scope 或 file scope， 对 我们 而言， 都是 由 系统 自动 管理。 第三 种 储存 期 形式 称为 dynamic extent（ 动态 范围）。 其内 存 系由 程序 的 空闲 空间（ free store） 分配 而来， 有时 也称 为 heap memory（ 堆 内存）。 这种 内存 必须 由 程序员 自行 管理， 其 分配 系 通过 new 表达式 来 完成， 而 其 释放 则 通过 delete 表达式 完成。

侯捷. Essential C++中文版 (p. 82). 电子工业出版社. Kindle 版本. 



## const



## static

### 静态对象、方法

### 局部静态对象

在方法内用static定义或声明

``` c++
void Add(int val)
{
    static vector<int> tempElements;
    tempElements.push_back(val);
}
```

局部静态对象所处的内存空间，即使在不同的函数调用过程中，依然持续存在，不会因为每次调用函数就会被破坏再重建

## extern



## inline



## 构造函数默认值

应该在头文件中定义构造函数默认值，否则会报找不到匹配的构造函数的错误

GameObject.h

``` c++
#pragma once

namespace BorderlessEngine
{
	class GameObject
	{
	public:
		GameObject(const char* newName = "New GameObject", bool isActive = true);
        		
		char* name;
		bool isActive;
		~GameObject();
	private:
		void SetName(const char* name);
}
```

GameObject.cpp

``` c++
#include "GameObject.h"
#include <cstring>

namespace BorderlessEngine
{
	GameObject::GameObject(const char* newName, bool isActive)
	{
		SetName(newName);
		this->isActive = isActive;
	}

	GameObject::~GameObject()
	{
		delete[] name;
	}
    
    void GameObject::SetName(const char* name)
	{
		// 这里分配的内存空间为sizeof(defaultName)，而不是strlen(defaultName)
		this->name = new char[sizeof(name)];
		// 否则这里copyedName的长度就会比defaultName少1，无法拷贝结束字符'\0'
		strcpy(this->name, name);
	}
}
```

## 运行时的类型鉴定机制

``` c++
class A {}

class B : public A 
{
public:
    TestB(){}
}

void main()
{
    auto b = new B();
    A* a = b;
    if (typeid(*a) == typeid(B))
    {
        // 无条件转换
        B* b2 = static_cast<B*>(a);
    }
    // 先检查a所指向对象是否是B类型，如果是则转换操作发生，否则失败且返回0
    if (B* b3 = dynamic_cast<B*>(a))
    {
        b3->TestB();
    }
    delete b;
}
```

