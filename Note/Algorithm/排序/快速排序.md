### 快速排序C# 递归实现

    void QuickSort(int[] array, int low, int high)
    {
        if (low >= high)
        {
            return;
        }

        int pivot = array[low];
        int left = low;
        int right = high;

        while (left < right)
        {
            while (array[right] >= pivot && left < right)
            {
                right--;
            }
            array[left] = array[right];
            while (array[left] <= pivot && left < right)
            {
                left++;
            }
            array[right] = array[left];
        }

        // 把pivot填入结束位置
        array[left] = pivot;

        // pivot已位于正确位置
        // 对pivot左边的序列排序
        QuickSort(array, low, left - 1);
        // 对pivot右边的序列排序
        QuickSort(array, left + 1, high);
    }

### 快速排序关键点
- 单调性：每次迭代完成后，left,right相遇位置为p，那么有 p左边所有元素 < pivot < p右边所有元素，根据单调性可知，此时该位置p的元素必然为pivot。（此时至少使得p有序）
- 分而治之：每次迭代完成后，由于p已经有序，而p的左右两边仍可能无序，于是将序列分为p的左边、p的右边共2个序列，继续排序。

### 为什么要让left和right交替移动，而不是直接从一端线性扫描到另一端？
以right为例。  
right认为自己当前所在位置就是pivot应该放置的位置，发现 当前位置的元素>pivot 后，right认为pivot应该在更左边的位置，于是向左移动，而如果发现 当前位置的元素>pivot ，right会将这个元素丢到左边去，并在当前位置留个空位，认为当前这个位置就应该放pivot了。  
那么这个比pivot小的元素要丢到right左边的具体哪个位置呢？应该丢到left上。**其实是应该插入到left左边某个位置，然而插入就会发生无谓的移动。**丢给left正好，因为之后轮到left处理这个元素时，left会因为这个元素比pivot小，直接向右移动去处理下一个，这样一来这个元素恰好就被“丢”到left的左边了。  
那么为什么之后right不继续向左扫描，而是交给left来继续呢？因为right虽然认为当前所在位置就应该放pivot了，然而事实是只要left和right还没有相遇，pivot就不可能确定一个正确的位置，pivot这里留的空位，实际上是希望能够从right的左边拿到一个比pivot大的元素，然后继续向左扫描。  
right可以通过扫描left到right-1范围内的元素来找到这个元素，但是这样却是多此一举。如果把控制权交给left， **left自然也会对等地将一个比pivot大的元素丢过来，放在right上正好。**
因此一次right和left的处理，就是分别将比pivot小的元素丢到左边，再将比pivot大的元素丢到右边，实际上就是一次**以left和right共同作为pivot基准，将错误的元素进行交换**的操作。  
每进行一次这样的操作，left和right不断移动，使得left左边都是比pivot小的元素，right右边都是比pivot大的元素，当left与right相遇时，根据单调性，小于pivot的元素-相遇位置-大于pivot的元素，那么此时该位置只能是pivot应该放置的位置，所以最后一步是将缓存的pivot填入到这个位置上（并且也是left或right的操作留下的空位，空位是为了不需要移动其他元素就完成了交换）

### 为什么将序列的第一个选为pivot后，每次迭代要让right先移动，而后才让left移动呢？

##### 先left++，后right--
取序列的第一个元素3作为pivot，left=0，right=4
|**3**|1|2|5|4|
若先让left++，直到找到一个比pivot=3大的元素，即在left=3时找到元素5，则：

| **3** | 1 | 2 | 4 | 5 |  
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;l&ensp;&ensp;r

 再让right--，直到找到一个比pivot=3小的元素，即在right=3时找到元素4，则：

| **3** | 1 | 2 | 4 | 5 |  
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;l&ensp;r　

left < right不满足，此次迭代结束，pivot只得插入left和right相遇位置的左边一个，不得不先将左边的序列也就是1和2都移动到最左端，再插入pivot。  
 
##### 先right--，后left++
取序列的第一个元素3作为pivot，left=0，right=4  
| **3** | 1 | 2 | 5 | 4 |  
&ensp;l&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;r  
若先让right--，直到找到一个比pivot=3小的元素，即在right=2时找到元素2，将2丢给left，并在right留空  
| 2 | 1 | **X** | 5 | 4 |  
&ensp;l&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;r

之后步骤同理，总之就是  
**每次都留一个空位，并认为是pivot的正确位置，那么就免去了无谓的移动。**  
同理，**如果是取序列的最后一个元素作为pivot，那么应该反过来先让left++，再让right--**