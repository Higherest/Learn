### 属性

-   setter的可访问性应小于等于getter
-   如果属性仅具有setter，则将属性改为以Set开头的方法
-   如果setter抛出异常，则保留旧值
-   getter不要抛出异常，但索引器的getter可以

### 索引器属性

-   尽可能为集合类型提供索引器
-   不要使用多个参数的索引属性。如果有这样的需求，使用Get或Set开头的方法
-   优先提供索引器而不是方法来访问集合元素，两者不应同时存在

### 构造函数

-   应作为设置主要属性、字段的首要手段，效果和使用无参构造函数后再设置属性字段效果应一致
-   不要进行其他任何不必要的处理，而是将这些工作分摊到其他设置函数中，这样可以让初始化尽可能快地完成
-   如果构造函数中的参数用于设置属性字段，这些参数的命名应该和这些被设置的属性字段一致
-   **不要调用virtual成员**，考虑这样的情况：有派生类B继承自基类A，override了基类的Log函数，基类A的构造函数中调用了Log函数。如果调用A的构造函数则没问题，但如果调用B的构造函数，会先调用A的构造函数（再调用B自身的），A的构造函数中调用的Log函数却是B的override的Log函数，但此时B的构造函数还未执行，B很可能还未初始化完成

### 字段

-   不要提供public或protected字段，而是采用属性
-   仅将public static readonly字段用于预定义的对象实例（相当于单例模式）
-   将const字段用于永远不变的常量
-   不要将可变类型的实例分配给readonly字段

### 扩展方法

-   在与它们所属功能关联的名称空间中定义扩展方法
-   不要只是用Extensions等通用命名来命名其命名空间，而是用更具体的功能描述来命名

### 运算符重载

-   务必为表示数字的struct重载操作符，因为默认的Equals实现是不可靠的
-   如果要重载，一定要成对地重载操作符，比如 operator== 和 operator!=
-   考虑为重载的操作符提供对应名称的方法，比如operator+ 对应 Add()方法
-   不要在类型的域之外定义转换操作符，比如int是数字类型，而Datetime则不是，因此不要提供两者之间的转换
-   如果转换可能有损失（如double到int），不要提供隐式转换，但可以提供显示转换

### 参数

-   out参数放在按值引用和ref参数之后，可看作额外的返回值便于理解
-   不要在方法中修改参数（函数的副作用），而是通过使用返回值和参数的对应字段、属性的Set方法显示地修改
-   务必使用能够提供成员所需功能的最小派生参数类型，例如有成员方法的参数为IEnumerable类型，派生类的override成员方法的参数也应该使用IEnumerable类型，而不是派生类List等
-   务必为传递给public、protected成员的参数进行参数验证，因为我们假定private成员使用的参数都是经过验证的，其他部分则是无法确保参数正确的

