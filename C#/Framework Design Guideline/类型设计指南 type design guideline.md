### class和struct的选择

-   struct在一些情况下（如通过方法修改自身一些字段，为了避免装箱
-   **一般情况下，复制class实例的开销比struct要小**，因为值类型会复制所有值类型成员的值和引用类型成员的引用，而引用类型的拷贝仅复制所有成员的引用
-   需要继承关系来继承成员，则选择class
-   struct更适合存储简单的不可变的数值，仅包含简单的方法，如Vector2

### 抽象类

-   仅定义protected或internal的构造函数
-   提供至少一个派生自该抽象类的具体类型的实现

### struct

-   **务必实现```IEquatable<T>```接口**以提供更好的性能，因为默认的Object.Equals方法会导致装箱，且使用了反射（来检查所有字段是否相等）。而且有时候并不能正确地比较两个struct实例是否相同
-   确保即使将所有实例数据设置为0、false、null等默认值时是合法的，这样在用默认的无参构造函数来创建struct数组时，每个元素都是合法的
-   确保struct实例是不可变类型。如果可变，一些情况如将struct传入方法时形参实际是其拷贝，返回struct实例或struct之间赋值会产生struct副本，会复制所有值类型字段以及引用类型字段的引用。此时的修改实际上是在对副本进行修改，并不会影响到原对象的值类型字段，但是引用类型字段却又会受到影响，这通常会造成一些误用。如果不可变，且提供复制方法来显式地返回新生成的被修改后的副本，使用者就不会产生修改新对象会影响原对象的误用

### 枚举

-   如果明确了解枚举值的范围，可以使用Int32类型之外的枚举来节省内存
-   至少分配一个名称类似"None"或"Undefined"之类的空值，且用0作为值
-   标识枚举支持位运算，简单枚举用于表示较小的封闭集合
-   使用枚举而不是静态常量
-   不要将枚举用于开放的程序集（没有命名空间区分容易冲突）
-   枚举值如果只有一个，就不要用枚举了

### 嵌套类型

-   当需要某些类型仅能被特定类型访问，而不能被其他类型访问（更细致的可访问性控制）时，使用嵌套类型
-   如果是为了逻辑分组构造，使用命名空间而不是嵌套类型

